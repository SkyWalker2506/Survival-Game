// This code has been generated by the RMConvertor. Please do not attempt any changes


// SDF methods (sdf object sources & modifiers)
float4 IntersectionModifier(float sdf, half color, half materialType, half materialInstance, float4  targetSdf, half intersectSmoothness, half includeMaterial)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
    half3 colorB = targetSdf[0].gba;
    half materialTypeB = targetSdf[1].x;
    half materialInstanceB = targetSdf[1].y;
#elif defined(RAYMARCHER_TYPE_STANDARD)
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
    half materialTypeB = targetSdf.z;
    half materialInstanceB = targetSdf.w;
#else
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
#endif
    intersectSmoothness = abs(intersectSmoothness);
// Credits for the original formula: Inigo Quilez
// https://iquilezles.org/articles/distfunctions/
    float h = saturate(0.5 - 0.5 * (sdfB - sdf) / max(EPSILON, intersectSmoothness));
    sdf = lerp(sdfB, sdf, h ) + intersectSmoothness * h * (1.0 - h);
    color = lerp(colorB, color, h * includeMaterial);
#ifndef RAYMARCHER_TYPE_PERFORMANT
    materialType = lerp(materialTypeB, materialType, h);
    materialInstance = lerp(materialInstanceB, materialInstance, h * includeMaterial);
#endif

return float4 (sdf,color,materialType,materialInstance);
}

#ifndef Rot
#define Rot(a) float2x2(cos(a),-sin(a),sin(a),cos(a))
#endif
float3 TwistModifier(float3 p, half3 twistTile, half3 twistMultiplier, half3 twistScroll)
{

float3 m0 = lerp(0.0,0.05,twistMultiplier.y);
float3 m1 = lerp(0.0,0.05,twistMultiplier.x);
float3 m2 = lerp(0.0,0.05,twistMultiplier.z);

p.xz += mul(p.xz+5.0, Rot(p.y*twistTile.y+_Time.y*twistScroll.y)) * m0;
p.yz += mul(p.yz+5.0, Rot(p.x*twistTile.x+_Time.y*twistScroll.x)) * m1;
p.xy += mul(p.xy+5.0, Rot(p.z*twistTile.z+_Time.y*twistScroll.z)) * m2;

return p;
}

float2 GetApollonianFractalSdf(float3 p, half color, half4 fractalParams)
{
float result;
float sc = 1.0;
half colorProgression = 0.0;
p *= fractalParams.w;
for (int i = 0; i < 8; i++)
{
    p = -1.0 + 2.0 * frac(0.5 * p + 0.5);
    float r2 = dot(p, p);
    colorProgression += lerp(1.0f - colorProgression, (float)(cos(i * 0.5) * pow(r2, 0.5) + 0.15), clamp(fractalParams.z, 0, 1));
    float k = fractalParams.x / r2;
    p *= k;
    p.x *= fractalParams.y;
    sc *= k;
}
color *= colorProgression;
result = (0.25 * abs(p.y) / sc) / fractalParams.w;
return float2 (result,color);
}

float2 GetSphereSdf(float3 p, half color, half2 sphereSdfData)
{
float result;
p.y -= clamp(p.y, 0.0, sphereSdfData.y);
result = length(p) - sphereSdfData.x;
return float2 (result,color);
}


// SDF object variables
struct SdfInstancesContainer
{
half4x4 modelData;
};
StructuredBuffer<SdfInstancesContainer> SdfInstances;
uniform half intersectSmoothness0;
uniform half includeMaterial0;
uniform half3 twistTile0;
uniform half3 twistMultiplier0;
uniform half3 twistScroll0;
uniform half4 fractalParams0;
uniform half2 sphereSdfData1;

float4 SdfObjectBuffer(in float3 p)
{
// SDF object declarations
    float4 obj0 = float4 (GetApollonianFractalSdf(TwistModifier(RM_TRANS(p,SdfInstances[0].modelData),twistTile0,twistMultiplier0,twistScroll0),SdfInstances[0].modelData[3].x,fractalParams0),-1,0);
    float4 obj1 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[1].modelData),SdfInstances[1].modelData[3].x,sphereSdfData1),-1,0);
// SDF modifier groups
    float4 objModifierGroup0 = IntersectionModifier(obj0.x,obj0.y,obj0.z,obj0.w,obj1,intersectSmoothness0,includeMaterial0);

// Smooth Unions
    return objModifierGroup0;
}
