// This code has been generated by the RMConvertor. Please do not attempt any changes


// SDF methods (sdf object sources & modifiers)
float3 DisplaceModifierXZ(float3 p, sampler2D displaceTexture, half textureTiling, half displacementAmount)
{
p.xy -= RM_SAMPLE_TEXTURE2D(displaceTexture, p.xz * textureTiling).r * displacementAmount;
return p;
}

float2 GetCubeSdf(float3 p, half color, half cubeRoundness, half3 cubeSize)
{
float result;
result = length(max(abs(p) - abs(cubeSize) + cubeRoundness, 0.0)) - cubeRoundness;
return float2 (result,color);
}

float4 FragmentModifier(float sdf, float3 p, half color, half materialType, half materialInstance, half4 fragmentTiling, half3 fragmentScroll)
{
float frg = (sin(fragmentTiling.x * (p.x + _Time.y * fragmentScroll.x))
* sin(fragmentTiling.y * (p.y + _Time.y * fragmentScroll.y))
* sin(fragmentTiling.z * (p.z + _Time.y * fragmentScroll.z))) * fragmentTiling.w;
sdf += frg;
return float4 (sdf,color,materialType,materialInstance);
}

float2 GetSphereSdf(float3 p, half color, half2 sphereSdfData)
{
float result;
p.y -= clamp(p.y, 0.0, sphereSdfData.y);
result = length(p) - sphereSdfData.x;
return float2 (result,color);
}

float2 GetMetaBallsSdf(float3 p, half color, half4 metaBallTransform, half2 metaBallFloating)
{
float result;

float t = _Time.y * metaBallFloating.x;
float ball0 = length(p + half3(-0.2 - sin(t / 1.5) * 0.2, metaBallFloating.y, 0.2 + cos(t / 0.5) * 0.2) * sin(t / 0.89) * metaBallTransform.z) - metaBallTransform.x - ((1.8 + cos(t)) * metaBallTransform.w);
float ball1 = length(p + half3(0.2 + cos(t / 0.49) * 0.2, metaBallFloating.y, -0.2 + sin(t / 1.24) * 0.2) * cos(t / 1.32) * metaBallTransform.z) - metaBallTransform.x - ((1.5 + sin(t / 2.8)) * metaBallTransform.w);
float ball2 = length(p + half3(0.1 + cos(t / 2.19) * 0.1, metaBallFloating.y, 0.1 + sin(t / 2.0) * 0.1) * cos(t / 2.0) * metaBallTransform.z) - metaBallTransform.x - ((1.2 + sin(t / 3.4)) * metaBallTransform.w);
float metaballs = SmoothUnion1(ball2, SmoothUnion1(ball0, ball1, metaBallTransform.y), metaBallTransform.y);
result = metaballs;
return float2 (result,color);
}

#ifndef Rot
#define Rot(a) float2x2(cos(a),-sin(a),sin(a),cos(a))
#endif
float3 TwistModifier(float3 p, half3 twistTile, half3 twistMultiplier, half3 twistScroll)
{

float3 m0 = lerp(0.0,0.05,twistMultiplier.y);
float3 m1 = lerp(0.0,0.05,twistMultiplier.x);
float3 m2 = lerp(0.0,0.05,twistMultiplier.z);

p.xz += mul(p.xz+5.0, Rot(p.y*twistTile.y+_Time.y*twistScroll.y)) * m0;
p.yz += mul(p.yz+5.0, Rot(p.x*twistTile.x+_Time.y*twistScroll.x)) * m1;
p.xy += mul(p.xy+5.0, Rot(p.z*twistTile.z+_Time.y*twistScroll.z)) * m2;

return p;
}

float3 yRepeatCountModifier(float3 p, half spacingy, half repeatCounty)
{
float sp = spacingy * 0.5;
p.y = p.y - sp *max(0, min(round(p.y.x / sp), repeatCounty));

return p;
}

float2 GetTorusSdf(float3 p, half color, half torusThickness, half torusRadius, half torusHeight)
{
float result;
p.y -= clamp(p.y, 0.0, torusHeight);
result = length(float2(length(p.xz) - torusRadius, p.y)) - torusThickness;
return float2 (result,color);
}

float2 GetLineSdf(float3 p, half color, half3 pointA, half3 pointB, half2 thickness)
{
float result;
float3 ab = pointB - pointA;
float h = min(1., max(0., dot(p - pointA, ab) / dot(ab, ab)));
result = length(p - pointA - (ab * h)) - lerp(thickness.x, thickness.y, h);
return float2 (result,color);
}

float3 DeformModifier(float3 p, half3 DeformData)
{
p.xz *= lerp(1., DeformData.z, smoothstep(DeformData.x - DeformData.y, DeformData.x + DeformData.y, p.y));
return p;
}

float3 xRepeatCountModifier(float3 p, half spacingx, half repeatCountx)
{
float sp = spacingx * 0.5;
p.x = p.x - sp *max(0, min(round(p.x.x / sp), repeatCountx));

return p;
}

float2 GetCubeFrameSdf(float3 p, half color, half cubeRoundness, half3 cubeSize, half frameSize)
{
float result;
float cYframe = length(max(abs(p) - (abs(cubeSize) + half3(0, 1, 0) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
float cZframe = length(max(abs(p) - (abs(cubeSize) + half3(0, 0, 1) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
float cXframe = length(max(abs(p) - (abs(cubeSize) + half3(1, 0, 0) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
result = max(-min(cYframe, min(cZframe, cXframe)), length(max(abs(p) - abs(cubeSize) + cubeRoundness, 0.0)) - cubeRoundness);
return float2 (result,color);
}

float4 SubtractionModifier(float sdf, half color, half materialType, half materialInstance, float4  targetSdf, half subtractSmoothness, half includeMaterial)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
    half3 colorB = targetSdf[0].gba;
    half materialTypeB = targetSdf[1].x;
    half materialInstanceB = targetSdf[1].y;
#elif defined(RAYMARCHER_TYPE_STANDARD)
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
    half materialTypeB = targetSdf.z;
    half materialInstanceB = targetSdf.w;
#else
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
#endif
    subtractSmoothness = abs(subtractSmoothness);
// Credits for the original formula: Inigo Quilez
// https://iquilezles.org/articles/distfunctions/
    float h = saturate(0.5 - 0.5 * (sdfB + sdf) / max(EPSILON, subtractSmoothness));
    sdf = lerp(sdfB, -sdf, h ) + subtractSmoothness * h * (1.0 - h);
    color = lerp(colorB, color, h * includeMaterial);
#ifndef RAYMARCHER_TYPE_PERFORMANT
    materialType = lerp(materialTypeB, materialType, h);
    materialInstance = lerp(materialInstanceB, materialInstance, h * includeMaterial);
#endif

return float4 (sdf,color,materialType,materialInstance);
}


// SDF object variables
struct SdfInstancesContainer
{
half4x4 modelData;
};
StructuredBuffer<SdfInstancesContainer> SdfInstances;
uniform sampler2D displaceTexture0;
uniform half textureTiling0;
uniform half displacementAmount0;
uniform half cubeRoundness0;
uniform half3 cubeSize0;
uniform half4 fragmentTiling1;
uniform half3 fragmentScroll1;
uniform half2 sphereSdfData1;
uniform half4 metaBallTransform2;
uniform half2 metaBallFloating2;
uniform half3 twistTile3;
uniform half3 twistMultiplier3;
uniform half3 twistScroll3;
uniform half spacingy3;
uniform half repeatCounty3;
uniform half torusThickness3;
uniform half torusRadius3;
uniform half torusHeight3;
uniform half3 pointA4;
uniform half3 pointB4;
uniform half2 thickness4;
uniform half3 DeformData5;
uniform half spacingx5;
uniform half repeatCountx5;
uniform half cubeRoundness5;
uniform half3 cubeSize5;
uniform half frameSize5;
uniform half subtractSmoothness6;
uniform half includeMaterial6;
uniform half2 sphereSdfData6;

float4 SdfObjectBuffer(in float3 p)
{
// SDF object declarations
    float4 obj0 = float4 (GetCubeSdf(DisplaceModifierXZ(RM_TRANS(p,SdfInstances[0].modelData),displaceTexture0,textureTiling0,displacementAmount0),SdfInstances[0].modelData[3].x,cubeRoundness0,cubeSize0),0,0);
    float4 obj1 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[1].modelData),SdfInstances[1].modelData[3].x,sphereSdfData1),0,1);
    obj1 = FragmentModifier(obj1.x,p,obj1.y,obj1.z,obj1.w,fragmentTiling1,fragmentScroll1);
    float4 obj2 = float4 (GetMetaBallsSdf(RM_TRANS(p,SdfInstances[2].modelData),SdfInstances[2].modelData[3].x,metaBallTransform2,metaBallFloating2),0,1);
    float4 obj3 = float4 (GetTorusSdf(yRepeatCountModifier(TwistModifier(RM_TRANS(p,SdfInstances[3].modelData),twistTile3,twistMultiplier3,twistScroll3),spacingy3,repeatCounty3),SdfInstances[3].modelData[3].x,torusThickness3,torusRadius3,torusHeight3),0,1);
    float4 obj4 = float4 (GetLineSdf(RM_TRANS(p,SdfInstances[4].modelData),SdfInstances[4].modelData[3].x,pointA4,pointB4,thickness4),0,1);
    float4 obj5 = float4 (GetCubeFrameSdf(xRepeatCountModifier(DeformModifier(RM_TRANS(p,SdfInstances[5].modelData),DeformData5),spacingx5,repeatCountx5),SdfInstances[5].modelData[3].x,cubeRoundness5,cubeSize5,frameSize5),0,1);
    float4 obj6 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[6].modelData),SdfInstances[6].modelData[3].x,sphereSdfData6),0,1);
// SDF modifier groups
    float4 objModifierGroup0 = SubtractionModifier(obj6.x,obj6.y,obj6.z,obj6.w,obj1,subtractSmoothness6,includeMaterial6);

// Smooth Unions
    float4 objGroup0 = GroupSmoothUnion(objModifierGroup0,obj0,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup1 = GroupSmoothUnion(objGroup0,obj2,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup2 = GroupSmoothUnion(objGroup1,obj3,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup3 = GroupSmoothUnion(objGroup2,obj4,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup4 = GroupSmoothUnion(objGroup3,obj5,RaymarcherGlobalSdfObjectSmoothness);
    return objGroup4;
}
