// This code has been generated by the RMConvertor. Please do not attempt any changes


// SDF methods (sdf object sources & modifiers)
half2 FragmentModifier(half sdf, float3 p, half color, half4 fragmentTiling, half3 fragmentScroll)
{
float frg = (sin(fragmentTiling.x * (p.x + _Time.y * fragmentScroll.x))
* sin(fragmentTiling.y * (p.y + _Time.y * fragmentScroll.y))
* sin(fragmentTiling.z * (p.z + _Time.y * fragmentScroll.z))) * fragmentTiling.w;
sdf += frg;
return half2 (sdf,color);
}

half2 GetCubeSdf(half3 p, half color, half cubeRoundness, half3 cubeSize)
{
half result;
result = length(max(abs(p) - abs(cubeSize) + cubeRoundness, 0.0)) - cubeRoundness;
return half2 (result,color);
}

half2 SubtractionModifier(half sdf, half color, half2  targetSdf, half subtractSmoothness, half includeMaterial)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
    half3 colorB = targetSdf[0].gba;
    half materialTypeB = targetSdf[1].x;
    half materialInstanceB = targetSdf[1].y;
#elif defined(RAYMARCHER_TYPE_STANDARD)
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
    half materialTypeB = targetSdf.z;
    half materialInstanceB = targetSdf.w;
#else
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
#endif
    subtractSmoothness = abs(subtractSmoothness);
// Credits for the original formula: Inigo Quilez
// https://iquilezles.org/articles/distfunctions/
    float h = saturate(0.5 - 0.5 * (sdfB + sdf) / max(EPSILON, subtractSmoothness));
    sdf = lerp(sdfB, -sdf, h ) + subtractSmoothness * h * (1.0 - h);
    color = lerp(colorB, color, h * includeMaterial);
#ifndef RAYMARCHER_TYPE_PERFORMANT
    materialType = lerp(materialTypeB, materialType, h);
    materialInstance = lerp(materialInstanceB, materialInstance, h * includeMaterial);
#endif

return half2 (sdf,color);
}

half2 GetTorusSdf(half3 p, half color, half torusThickness, half torusRadius, half torusHeight)
{
half result;
p.y -= clamp(p.y, 0.0, torusHeight);
result = length(float2(length(p.xz) - torusRadius, p.y)) - torusThickness;
return half2 (result,color);
}

half2 GetConeSdf(half3 p, half color, half coneHeight, half coneSize)
{
half result;
result = max(dot(float2(0.5, coneSize), float2(length(p.xz), p.y - coneHeight)), -p.y - coneHeight);
return half2 (result,color);
}

half2 MorphModifier(half sdf, half color, half2  targetSdf, half morphValue)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
#else
    float sdfB = targetSdf.x;
#endif
    sdf = lerp(sdf, sdfB, morphValue);

return half2 (sdf,color);
}

half2 GetMetaBallsSdf(half3 p, half color, half4 metaBallTransform, half2 metaBallFloating)
{
half result;

float t = _Time.y * metaBallFloating.x;
float ball0 = length(p + half3(-0.2 - sin(t / 1.5) * 0.2, metaBallFloating.y, 0.2 + cos(t / 0.5) * 0.2) * sin(t / 0.89) * metaBallTransform.z) - metaBallTransform.x - ((1.8 + cos(t)) * metaBallTransform.w);
float ball1 = length(p + half3(0.2 + cos(t / 0.49) * 0.2, metaBallFloating.y, -0.2 + sin(t / 1.24) * 0.2) * cos(t / 1.32) * metaBallTransform.z) - metaBallTransform.x - ((1.5 + sin(t / 2.8)) * metaBallTransform.w);
float ball2 = length(p + half3(0.1 + cos(t / 2.19) * 0.1, metaBallFloating.y, 0.1 + sin(t / 2.0) * 0.1) * cos(t / 2.0) * metaBallTransform.z) - metaBallTransform.x - ((1.2 + sin(t / 3.4)) * metaBallTransform.w);
float metaballs = SmoothUnion1(ball2, SmoothUnion1(ball0, ball1, metaBallTransform.y), metaBallTransform.y);
result = metaballs;
return half2 (result,color);
}

half2 IntersectionModifier(half sdf, half color, half2  targetSdf, half intersectSmoothness, half includeMaterial)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
    half3 colorB = targetSdf[0].gba;
    half materialTypeB = targetSdf[1].x;
    half materialInstanceB = targetSdf[1].y;
#elif defined(RAYMARCHER_TYPE_STANDARD)
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
    half materialTypeB = targetSdf.z;
    half materialInstanceB = targetSdf.w;
#else
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
#endif
    intersectSmoothness = abs(intersectSmoothness);
// Credits for the original formula: Inigo Quilez
// https://iquilezles.org/articles/distfunctions/
    float h = saturate(0.5 - 0.5 * (sdfB - sdf) / max(EPSILON, intersectSmoothness));
    sdf = lerp(sdfB, sdf, h ) + intersectSmoothness * h * (1.0 - h);
    color = lerp(colorB, color, h * includeMaterial);
#ifndef RAYMARCHER_TYPE_PERFORMANT
    materialType = lerp(materialTypeB, materialType, h);
    materialInstance = lerp(materialInstanceB, materialInstance, h * includeMaterial);
#endif

return half2 (sdf,color);
}

half2 GetCubeFrameSdf(half3 p, half color, half cubeRoundness, half3 cubeSize, half frameSize)
{
half result;
float cYframe = length(max(abs(p) - (abs(cubeSize) + half3(0, 1, 0) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
float cZframe = length(max(abs(p) - (abs(cubeSize) + half3(0, 0, 1) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
float cXframe = length(max(abs(p) - (abs(cubeSize) + half3(1, 0, 0) - abs(frameSize) - cubeRoundness), 0.0)) - cubeRoundness;
result = max(-min(cYframe, min(cZframe, cXframe)), length(max(abs(p) - abs(cubeSize) + cubeRoundness, 0.0)) - cubeRoundness);
return half2 (result,color);
}

half2 GetSphereSdf(half3 p, half color, half2 sphereSdfData)
{
half result;
p.y -= clamp(p.y, 0.0, sphereSdfData.y);
result = length(p) - sphereSdfData.x;
return half2 (result,color);
}


// SDF object variables
struct SdfInstancesContainer
{
half4 modelData;
};
StructuredBuffer<SdfInstancesContainer> SdfInstances;
uniform half4 fragmentTiling0;
uniform half3 fragmentScroll0;
uniform half cubeRoundness0;
uniform half3 cubeSize0;
uniform half subtractSmoothness1;
uniform half includeMaterial1;
uniform half torusThickness1;
uniform half torusRadius1;
uniform half torusHeight1;
uniform half coneHeight2;
uniform half coneSize2;
uniform half morphValue3;
uniform half4 metaBallTransform3;
uniform half2 metaBallFloating3;
uniform half intersectSmoothness4;
uniform half includeMaterial4;
uniform half cubeRoundness4;
uniform half3 cubeSize4;
uniform half frameSize4;
uniform half2 sphereSdfData5;

half2 SdfObjectBuffer(in half3 p)
{
// SDF object declarations
    half2 obj0 = half2 (GetCubeSdf(RM_TRANS(p,SdfInstances[0].modelData.xyz),SdfInstances[0].modelData.w,cubeRoundness0,cubeSize0));
    obj0 = FragmentModifier(obj0.x,p,obj0.y,fragmentTiling0,fragmentScroll0);
    half2 obj1 = half2 (GetTorusSdf(RM_TRANS(p,SdfInstances[1].modelData.xyz),SdfInstances[1].modelData.w,torusThickness1,torusRadius1,torusHeight1));
    half2 obj2 = half2 (GetConeSdf(RM_TRANS(p,SdfInstances[2].modelData.xyz),SdfInstances[2].modelData.w,coneHeight2,coneSize2));
    half2 obj3 = half2 (GetMetaBallsSdf(RM_TRANS(p,SdfInstances[3].modelData.xyz),SdfInstances[3].modelData.w,metaBallTransform3,metaBallFloating3));
    half2 obj4 = half2 (GetCubeFrameSdf(RM_TRANS(p,SdfInstances[4].modelData.xyz),SdfInstances[4].modelData.w,cubeRoundness4,cubeSize4,frameSize4));
    half2 obj5 = half2 (GetSphereSdf(RM_TRANS(p,SdfInstances[5].modelData.xyz),SdfInstances[5].modelData.w,sphereSdfData5));
// SDF modifier groups
    half2 objModifierGroup0 = SubtractionModifier(obj1.x,obj1.y,obj0,subtractSmoothness1,includeMaterial1);
    half2 objModifierGroup1 = MorphModifier(obj3.x,obj3.y,obj2,morphValue3);
    half2 objModifierGroup2 = IntersectionModifier(obj4.x,obj4.y,obj5,intersectSmoothness4,includeMaterial4);

// Smooth Unions
    half2 objGroup0 = GroupSmoothUnion(objModifierGroup0,objModifierGroup1,RaymarcherGlobalSdfObjectSmoothness);
    half2 objGroup1 = GroupSmoothUnion(objGroup0,objModifierGroup2,RaymarcherGlobalSdfObjectSmoothness);
    return objGroup1;
}
