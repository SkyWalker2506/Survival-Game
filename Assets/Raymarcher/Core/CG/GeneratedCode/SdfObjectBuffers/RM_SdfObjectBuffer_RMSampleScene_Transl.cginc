// This code has been generated by the RMConvertor. Please do not attempt any changes


// SDF methods (sdf object sources & modifiers)
float2 GetCubeSdf(float3 p, half color, half cubeRoundness, half3 cubeSize)
{
float result;
result = length(max(abs(p) - abs(cubeSize) + cubeRoundness, 0.0)) - cubeRoundness;
return float2 (result,color);
}

#ifndef Rot
#define Rot(a) float2x2(cos(a),-sin(a),sin(a),cos(a))
#endif
float3 TwistModifier(float3 p, half3 twistTile, half3 twistMultiplier, half3 twistScroll)
{

float3 m0 = lerp(0.0,0.05,twistMultiplier.y);
float3 m1 = lerp(0.0,0.05,twistMultiplier.x);
float3 m2 = lerp(0.0,0.05,twistMultiplier.z);

p.xz += mul(p.xz+5.0, Rot(p.y*twistTile.y+_Time.y*twistScroll.y)) * m0;
p.yz += mul(p.yz+5.0, Rot(p.x*twistTile.x+_Time.y*twistScroll.x)) * m1;
p.xy += mul(p.xy+5.0, Rot(p.z*twistTile.z+_Time.y*twistScroll.z)) * m2;

return p;
}

float2 GetSphereSdf(float3 p, half color, half2 sphereSdfData)
{
float result;
p.y -= clamp(p.y, 0.0, sphereSdfData.y);
result = length(p) - sphereSdfData.x;
return float2 (result,color);
}

float4 SubtractionModifier(float sdf, half color, half materialType, half materialInstance, float4  targetSdf, half subtractSmoothness, half includeMaterial)
{

#ifdef RAYMARCHER_TYPE_QUALITY
    float sdfB = targetSdf[0].x;
    half3 colorB = targetSdf[0].gba;
    half materialTypeB = targetSdf[1].x;
    half materialInstanceB = targetSdf[1].y;
#elif defined(RAYMARCHER_TYPE_STANDARD)
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
    half materialTypeB = targetSdf.z;
    half materialInstanceB = targetSdf.w;
#else
    float sdfB = targetSdf.x;
    half3 colorB = targetSdf.y;
#endif
    subtractSmoothness = abs(subtractSmoothness);
// Credits for the original formula: Inigo Quilez
// https://iquilezles.org/articles/distfunctions/
    float h = saturate(0.5 - 0.5 * (sdfB + sdf) / max(EPSILON, subtractSmoothness));
    sdf = lerp(sdfB, -sdf, h ) + subtractSmoothness * h * (1.0 - h);
    color = lerp(colorB, color, h * includeMaterial);
#ifndef RAYMARCHER_TYPE_PERFORMANT
    materialType = lerp(materialTypeB, materialType, h);
    materialInstance = lerp(materialInstanceB, materialInstance, h * includeMaterial);
#endif

return float4 (sdf,color,materialType,materialInstance);
}


// SDF object variables
struct SdfInstancesContainer
{
half4x4 modelData;
};
StructuredBuffer<SdfInstancesContainer> SdfInstances;
uniform half cubeRoundness0;
uniform half3 cubeSize0;
uniform half3 twistTile1;
uniform half3 twistMultiplier1;
uniform half3 twistScroll1;
uniform half2 sphereSdfData1;
uniform half2 sphereSdfData2;
uniform half2 sphereSdfData3;
uniform half subtractSmoothness4;
uniform half includeMaterial4;
uniform half2 sphereSdfData4;

float4 SdfObjectBuffer(in float3 p)
{
// SDF object declarations
    float4 obj0 = float4 (GetCubeSdf(RM_TRANS(p,SdfInstances[0].modelData),SdfInstances[0].modelData[3].x,cubeRoundness0,cubeSize0),0,0);
    float4 obj1 = float4 (GetSphereSdf(TwistModifier(RM_TRANS(p,SdfInstances[1].modelData),twistTile1,twistMultiplier1,twistScroll1),SdfInstances[1].modelData[3].x,sphereSdfData1),0,1);
    float4 obj2 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[2].modelData),SdfInstances[2].modelData[3].x,sphereSdfData2),0,1);
    float4 obj3 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[3].modelData),SdfInstances[3].modelData[3].x,sphereSdfData3),0,1);
    float4 obj4 = float4 (GetSphereSdf(RM_TRANS(p,SdfInstances[4].modelData),SdfInstances[4].modelData[3].x,sphereSdfData4),0,1);
// SDF modifier groups
    float4 objModifierGroup0 = SubtractionModifier(obj4.x,obj4.y,obj4.z,obj4.w,obj1,subtractSmoothness4,includeMaterial4);

// Smooth Unions
    float4 objGroup0 = GroupSmoothUnion(objModifierGroup0,obj0,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup1 = GroupSmoothUnion(objGroup0,obj2,RaymarcherGlobalSdfObjectSmoothness);
    float4 objGroup2 = GroupSmoothUnion(objGroup1,obj3,RaymarcherGlobalSdfObjectSmoothness);
    return objGroup2;
}
